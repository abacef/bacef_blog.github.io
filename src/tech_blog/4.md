
So I unintentionally pushed a bug to production once. When the root cause was discovered, it made one of my usually reserved co-workers exclaim "I hate Python"

## The Code

The problem statement was that I had to go through a list and if any items in a list were in another list, filter them out. This is the code I wrote.

```python
for item in list_to_filter:
    if item in removable_items:
        list_to_filter.remove(item)
```

Here is a unit test I probably wrote for this code

```python
list_to_filter = ["a", "b", "a", "c", "e", "f"]
removable_items = ["a", "e"]

answer = ["b", "c", "f"]
```

Which is a usual example of the distribution of the things we needed to filter, and it worked. After releasing to production though, we found an issue, the resulting list was not removing all the items in some cases.

## The Investigation

While I was in the thick of working on another project, my manager assigned another person to work on fixing this bug. After two days (and nights) of looking at this pretty bad bug, he was able to find the issue. Here is a test case that fails

```python
list_to_filter = ["a", "b", "a", "c", "e", "f"]
removable_items = ["a", "b"]
```

was returning a filtered list
```python
["b", "c", "e", "f"]
```
without filtering out the `"b"`. Do you spot the issue yet?

Was it not looking at the whole list to filter out the `b`? But if we put the `"b"` at the end of the list to filter, it would get filtered out

Here is a min repro of the issue
```python
list_to_filter = ["a", "a"]
removable_items = ["a"]
```

Would result in
```python
["a"]
```

Do you spot the issue yet?

So apparently Python converts this code into something like a counting for loop at runtime, effectively de-sugaring my code into
```python
for i in range(len(list_to_filter)):
    item = list_to_filter[i]
    if item in removable_items:
        list_to_filter.remove(item)
```
but notably it does not fail when the list range is out of bounds somehow

Now that I revealed about the out of bounds thing, do you spot the issue now?

Ok I am going to tell you the issue now.

## Code Trace of the bug

Essentially when the list needs to go to the next item, it does not loop **for all the items in the list to filter** like it seems like I did in plain english, it just goes essentially to the next index each loop which means if the previous loop removed an element at index 1, the next index in the loop will be index 2, but the one that is now at index 1 was the one that was previously in index 2 but it got skipped over.

Code trace for the min repro:

1. The first item in the list to filter is an "a"
2. Is this "a" in  the removable items? yes it is, so remove the specific instance of this "a"
3. The list to filter is now ["a"]
4. Going on to the next iteration of the for loop, the second item in the list to filter is... wait there is no second item in the list? I guess we are done?


The person who fixed the bug asked me to review the fix. I forgot what the fix was but it passed the test cases that were failing before so I approved the review.

## Conclusion
So what could have been done differently in the future to prevent this bug? Well like all things it is complicated.

We were running this filtering code in a different service than the code that needed to be in python so it did not have to be written in python. This service started as a proof of concept in Python but when worked good enough and did not have any bugs yet, the ticket to convert it to another language was a low priority apart from a few engineers raising the alarm bells of Python's issues (slow, high memory, lack of real threads, weak typeness). This code in Java would throw a `ConcurrentModificationException` at runtime instead of modifying the list, and in Rust, the code will not even compile if there is a modification of the list being iterated over.

The culture of the lack of care of this service translated into my intentional choice of using a slower filtering algorithm in order to ship the product faster. The reviewer of my code probably noticed this choice but was as disolusioned as me as to the lack of effert we have put into this service for years that they did not even put in the effort to mention the slow algorithm choice.

Even though we could have pushed more for the service to be re-written and pushed more to take some sprint effort to clean up the code, would I do this any differently in the future? Probably not actually as long as I am working at a company with a high priority to push products out fast. Would it have been better to write the proof of concept in a different language? Maybe if it was ok for the release to be pushed back some time or people's promotions to be pushed back. Sometimes time to market matters and sometimes less code bugs matter and sometimes peoples promotions matter more but there is usually always a tradeoff. Unfortunately I dont think I am smart enough, mature enough, or experienced enough to know the best trade-off.





